use anyhow::Result;
use chrono::Utc;
use flate2::write::GzEncoder;
use flate2::Compression;
use rayon::prelude::*;
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{BufWriter, Write};
use tracing::info;

use crate::db::progress::{FormatProgress, FormatStatus, GenerationProgress, OutputFile};

/// Output format types
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum OutputFormat {
    Hosts,
    Plain,
    Adblock,
}

impl OutputFormat {
    pub fn as_str(&self) -> &'static str {
        match self {
            OutputFormat::Hosts => "hosts",
            OutputFormat::Plain => "plain",
            OutputFormat::Adblock => "adblock",
        }
    }

    pub fn file_suffix(&self) -> &'static str {
        match self {
            OutputFormat::Hosts => "_hosts.txt.gz",
            OutputFormat::Plain => "_plain.txt.gz",
            OutputFormat::Adblock => "_adblock.txt.gz",
        }
    }

    pub fn comment_prefix(&self) -> &'static str {
        match self {
            OutputFormat::Hosts | OutputFormat::Plain => "#",
            OutputFormat::Adblock => "!",
        }
    }

    pub fn all() -> Vec<OutputFormat> {
        vec![OutputFormat::Hosts, OutputFormat::Plain, OutputFormat::Adblock]
    }
}

/// Output file generator
pub struct OutputGenerator {
    output_dir: std::path::PathBuf,
}

impl OutputGenerator {
    /// Create a new output generator
    pub fn new(output_dir: impl Into<std::path::PathBuf>) -> Self {
        Self {
            output_dir: output_dir.into(),
        }
    }

    /// Generate header lines for output file
    fn generate_header(&self, format: OutputFormat, domain_count: u64) -> String {
        let prefix = format.comment_prefix();
        let now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

        format!(
            "{} Blocklist generated by lists.zachlagden.uk\n\
             {} Total domains: {}\n\
             {} Generated: {}\n\n",
            prefix, prefix, domain_count, prefix, now
        )
    }

    /// Write a domain directly to encoder without intermediate String allocation
    /// For hosts/plain: always uses domain format
    /// For adblock: uses raw_rule if available, otherwise generates ||domain^
    #[inline]
    fn write_domain<W: Write>(
        encoder: &mut W,
        format: OutputFormat,
        domain: &str,
        adblock_rules: Option<&HashMap<String, String>>,
    ) -> std::io::Result<()> {
        match format {
            OutputFormat::Hosts => {
                encoder.write_all(b"0.0.0.0 ")?;
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"\n")?;
            }
            OutputFormat::Plain => {
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"\n")?;
            }
            OutputFormat::Adblock => {
                // For adblock format, use raw rule if available (preserves modifiers)
                if let Some(rules) = adblock_rules {
                    if let Some(raw_rule) = rules.get(domain) {
                        encoder.write_all(raw_rule.as_bytes())?;
                        encoder.write_all(b"\n")?;
                        return Ok(());
                    }
                }
                // Fallback: generate standard adblock format (for hosts/plain sources)
                encoder.write_all(b"||")?;
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"^\n")?;
            }
        }
        Ok(())
    }

    /// Generate a single output file (optimized: zero string allocations per domain)
    pub fn generate_file(
        &self,
        format: OutputFormat,
        domains: &[String],
        adblock_rules: &HashMap<String, String>,
        mut progress_callback: impl FnMut(u64, u64),
    ) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;
        let filename = format!("all_domains{}", format.file_suffix());
        let output_path = self.output_dir.join(&filename);

        // Ensure output directory exists
        fs::create_dir_all(&self.output_dir)?;

        // Create gzip encoder writing to file with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file); // 4MB buffer
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast()); // Level 1 for speed

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write domains directly without String allocation
        let update_interval = (total_domains / 100).max(1000);
        let rules_ref = if format == OutputFormat::Adblock { Some(adblock_rules) } else { None };
        for (i, domain) in domains.iter().enumerate() {
            Self::write_domain(&mut encoder, format, domain, rules_ref)?;

            // Progress callback (sparse)
            if i as u64 % update_interval == 0 {
                progress_callback(i as u64, total_domains);
            }
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;

        // Get file size
        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate a single output file without progress callback (for parallel execution)
    fn generate_file_parallel(
        &self,
        format: OutputFormat,
        domains: &[String],
        adblock_rules: &HashMap<String, String>,
    ) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;
        let filename = format!("all_domains{}", format.file_suffix());
        let output_path = self.output_dir.join(&filename);

        // Create gzip encoder with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file);
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast());

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write all domains directly
        let rules_ref = if format == OutputFormat::Adblock { Some(adblock_rules) } else { None };
        for domain in domains {
            Self::write_domain(&mut encoder, format, domain, rules_ref)?;
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;

        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate all output formats in parallel (optimized)
    pub fn generate_all(
        &self,
        domains: &[String],
        adblock_rules: &HashMap<String, String>,
        mut progress_callback: impl FnMut(&GenerationProgress),
    ) -> Result<Vec<OutputFile>> {
        let total_domains = domains.len() as u64;
        let formats = OutputFormat::all();

        // Ensure output directory exists before parallel execution
        fs::create_dir_all(&self.output_dir)?;

        // Initialize progress - show all as generating since they run in parallel
        let mut progress = GenerationProgress {
            current_format: Some("hosts, plain, adblock (parallel)".to_string()),
            formats: formats
                .iter()
                .map(|f| FormatProgress {
                    format: f.as_str().to_string(),
                    status: FormatStatus::Generating,
                    domains_written: 0,
                    total_domains,
                    percent: 0.0,
                    file_size: None,
                    gz_size: None,
                })
                .collect(),
        };

        progress_callback(&progress);

        // Generate all formats in parallel using rayon
        let results: Vec<Result<OutputFile>> = formats
            .par_iter()
            .map(|format| self.generate_file_parallel(*format, domains, adblock_rules))
            .collect();

        // Collect results and update progress
        let mut output_files = Vec::with_capacity(formats.len());
        for (idx, result) in results.into_iter().enumerate() {
            let output_file = result?;
            progress.formats[idx].status = FormatStatus::Completed;
            progress.formats[idx].domains_written = total_domains;
            progress.formats[idx].percent = 100.0;
            progress.formats[idx].gz_size = Some(output_file.size_bytes);
            output_files.push(output_file);
        }

        progress.current_format = None;
        progress_callback(&progress);

        Ok(output_files)
    }

    /// Generate a single category file (for parallel execution)
    fn generate_category_file(
        &self,
        category: Option<&str>,
        format: OutputFormat,
        domains: &[String],
        adblock_rules: &HashMap<String, String>,
    ) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;

        // Filename: category_format.txt.gz or uncategorized_format.txt.gz
        let filename = match category {
            Some(cat) => format!("{}_{}.txt.gz", cat, format.as_str()),
            None => format!("uncategorized_{}.txt.gz", format.as_str()),
        };
        let output_path = self.output_dir.join(&filename);

        // Create gzip encoder with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file);
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast());

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write all domains
        let rules_ref = if format == OutputFormat::Adblock { Some(adblock_rules) } else { None };
        for domain in domains {
            Self::write_domain(&mut encoder, format, domain, rules_ref)?;
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;
        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate output files for all categories in parallel
    pub fn generate_all_categories(
        &self,
        category_domains: &HashMap<Option<String>, Vec<String>>,
        adblock_rules: &HashMap<String, String>,
    ) -> Result<Vec<OutputFile>> {
        // Ensure output directory exists before parallel execution
        fs::create_dir_all(&self.output_dir)?;

        // Build task list: (category, format) pairs with domain reference
        let tasks: Vec<(Option<&str>, OutputFormat, &[String])> = category_domains
            .iter()
            .flat_map(|(cat, domains)| {
                OutputFormat::all().into_iter()
                    .map(move |fmt| (cat.as_deref(), fmt, domains.as_slice()))
            })
            .collect();

        info!(
            "Generating {} category files ({} categories Ã— 3 formats)",
            tasks.len(),
            category_domains.len()
        );

        // Generate all files in parallel using rayon
        let results: Vec<Result<OutputFile>> = tasks
            .par_iter()
            .map(|(category, format, domains)| {
                self.generate_category_file(*category, *format, domains, adblock_rules)
            })
            .collect();

        // Collect results
        let output_files: Result<Vec<OutputFile>> = results.into_iter().collect();
        output_files
    }

    /// Clean up old output files
    pub fn cleanup_old_files(&self) -> Result<()> {
        if !self.output_dir.exists() {
            return Ok(());
        }

        // Remove any legacy uncompressed files
        for entry in fs::read_dir(&self.output_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.extension().map(|e| e == "txt").unwrap_or(false) {
                // Check if it's not a .gz file (legacy uncompressed)
                let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
                if !filename.ends_with(".gz") {
                    info!("Removing legacy uncompressed file: {:?}", path);
                    fs::remove_file(path)?;
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_write_domain_hosts() {
        let mut buf = Vec::new();
        OutputGenerator::write_domain(&mut buf, OutputFormat::Hosts, "example.com", None).unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "0.0.0.0 example.com\n");
    }

    #[test]
    fn test_write_domain_plain() {
        let mut buf = Vec::new();
        OutputGenerator::write_domain(&mut buf, OutputFormat::Plain, "example.com", None).unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "example.com\n");
    }

    #[test]
    fn test_write_domain_adblock_no_rule() {
        let mut buf = Vec::new();
        // No adblock rule stored - generates default format
        OutputGenerator::write_domain(&mut buf, OutputFormat::Adblock, "example.com", None).unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "||example.com^\n");
    }

    #[test]
    fn test_write_domain_adblock_with_rule() {
        let mut buf = Vec::new();
        let mut rules = HashMap::new();
        rules.insert("example.com".to_string(), "||example.com^$important".to_string());

        // Has adblock rule - preserves original with modifiers
        OutputGenerator::write_domain(&mut buf, OutputFormat::Adblock, "example.com", Some(&rules)).unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "||example.com^$important\n");
    }

    #[test]
    fn test_write_domain_adblock_preserves_complex_rule() {
        let mut buf = Vec::new();
        let mut rules = HashMap::new();
        rules.insert("tracker.com".to_string(), "||tracker.com^$all,important".to_string());

        OutputGenerator::write_domain(&mut buf, OutputFormat::Adblock, "tracker.com", Some(&rules)).unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "||tracker.com^$all,important\n");
    }

    #[test]
    fn test_generate_file() {
        let temp_dir = TempDir::new().unwrap();
        let generator = OutputGenerator::new(temp_dir.path());

        let domains = vec!["ads.example.com".to_string(), "tracker.example.com".to_string()];
        let adblock_rules = HashMap::new();

        let output = generator
            .generate_file(OutputFormat::Hosts, &domains, &adblock_rules, |_, _| {})
            .unwrap();

        assert_eq!(output.format, "hosts");
        assert_eq!(output.domain_count, 2);
        assert!(output.size_bytes > 0);
        assert!(temp_dir.path().join(&output.name).exists());
    }

    #[test]
    fn test_generate_adblock_with_passthrough() {
        let temp_dir = TempDir::new().unwrap();
        let generator = OutputGenerator::new(temp_dir.path());

        let domains = vec!["ads.example.com".to_string(), "plain.example.com".to_string()];
        let mut adblock_rules = HashMap::new();
        // Only ads.example.com has an original rule
        adblock_rules.insert("ads.example.com".to_string(), "||ads.example.com^$important".to_string());
        // plain.example.com has no rule (came from hosts/plain source)

        let output = generator
            .generate_file(OutputFormat::Adblock, &domains, &adblock_rules, |_, _| {})
            .unwrap();

        assert_eq!(output.format, "adblock");
        assert_eq!(output.domain_count, 2);
        // File should contain ||ads.example.com^$important and ||plain.example.com^
    }
}
