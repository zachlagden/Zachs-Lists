use anyhow::Result;
use chrono::Utc;
use flate2::write::GzEncoder;
use flate2::Compression;
use rayon::prelude::*;
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{BufWriter, Write};
use tracing::info;

use crate::db::progress::{FormatProgress, FormatStatus, GenerationProgress, OutputFile};

/// Output format types
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum OutputFormat {
    Hosts,
    Plain,
    Adblock,
}

impl OutputFormat {
    pub fn as_str(&self) -> &'static str {
        match self {
            OutputFormat::Hosts => "hosts",
            OutputFormat::Plain => "plain",
            OutputFormat::Adblock => "adblock",
        }
    }

    pub fn file_suffix(&self) -> &'static str {
        match self {
            OutputFormat::Hosts => "_hosts.txt.gz",
            OutputFormat::Plain => "_plain.txt.gz",
            OutputFormat::Adblock => "_adblock.txt.gz",
        }
    }

    pub fn comment_prefix(&self) -> &'static str {
        match self {
            OutputFormat::Hosts | OutputFormat::Plain => "#",
            OutputFormat::Adblock => "!",
        }
    }

    pub fn all() -> Vec<OutputFormat> {
        vec![OutputFormat::Hosts, OutputFormat::Plain, OutputFormat::Adblock]
    }
}

/// Output file generator
pub struct OutputGenerator {
    output_dir: std::path::PathBuf,
}

impl OutputGenerator {
    /// Create a new output generator
    pub fn new(output_dir: impl Into<std::path::PathBuf>) -> Self {
        Self {
            output_dir: output_dir.into(),
        }
    }

    /// Generate header lines for output file
    fn generate_header(&self, format: OutputFormat, domain_count: u64) -> String {
        let prefix = format.comment_prefix();
        let now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

        format!(
            "{} Blocklist generated by lists.zachlagden.uk\n\
             {} Total domains: {}\n\
             {} Generated: {}\n\n",
            prefix, prefix, domain_count, prefix, now
        )
    }

    /// Write a domain directly to encoder without intermediate String allocation
    #[inline]
    fn write_domain<W: Write>(encoder: &mut W, format: OutputFormat, domain: &str) -> std::io::Result<()> {
        match format {
            OutputFormat::Hosts => {
                encoder.write_all(b"0.0.0.0 ")?;
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"\n")?;
            }
            OutputFormat::Plain => {
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"\n")?;
            }
            OutputFormat::Adblock => {
                encoder.write_all(b"||")?;
                encoder.write_all(domain.as_bytes())?;
                encoder.write_all(b"^\n")?;
            }
        }
        Ok(())
    }

    /// Generate a single output file (optimized: zero string allocations per domain)
    pub fn generate_file(
        &self,
        format: OutputFormat,
        domains: &[String],
        mut progress_callback: impl FnMut(u64, u64),
    ) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;
        let filename = format!("all_domains{}", format.file_suffix());
        let output_path = self.output_dir.join(&filename);

        // Ensure output directory exists
        fs::create_dir_all(&self.output_dir)?;

        // Create gzip encoder writing to file with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file); // 4MB buffer
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast()); // Level 1 for speed

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write domains directly without String allocation
        let update_interval = (total_domains / 100).max(1000);
        for (i, domain) in domains.iter().enumerate() {
            Self::write_domain(&mut encoder, format, domain)?;

            // Progress callback (sparse)
            if i as u64 % update_interval == 0 {
                progress_callback(i as u64, total_domains);
            }
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;

        // Get file size
        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate a single output file without progress callback (for parallel execution)
    fn generate_file_parallel(&self, format: OutputFormat, domains: &[String]) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;
        let filename = format!("all_domains{}", format.file_suffix());
        let output_path = self.output_dir.join(&filename);

        // Create gzip encoder with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file);
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast());

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write all domains directly
        for domain in domains {
            Self::write_domain(&mut encoder, format, domain)?;
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;

        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate all output formats in parallel (optimized)
    pub fn generate_all(
        &self,
        domains: &[String],
        mut progress_callback: impl FnMut(&GenerationProgress),
    ) -> Result<Vec<OutputFile>> {
        let total_domains = domains.len() as u64;
        let formats = OutputFormat::all();

        // Ensure output directory exists before parallel execution
        fs::create_dir_all(&self.output_dir)?;

        // Initialize progress - show all as generating since they run in parallel
        let mut progress = GenerationProgress {
            current_format: Some("hosts, plain, adblock (parallel)".to_string()),
            formats: formats
                .iter()
                .map(|f| FormatProgress {
                    format: f.as_str().to_string(),
                    status: FormatStatus::Generating,
                    domains_written: 0,
                    total_domains,
                    percent: 0.0,
                    file_size: None,
                    gz_size: None,
                })
                .collect(),
        };

        progress_callback(&progress);

        // Generate all formats in parallel using rayon
        let results: Vec<Result<OutputFile>> = formats
            .par_iter()
            .map(|format| self.generate_file_parallel(*format, domains))
            .collect();

        // Collect results and update progress
        let mut output_files = Vec::with_capacity(formats.len());
        for (idx, result) in results.into_iter().enumerate() {
            let output_file = result?;
            progress.formats[idx].status = FormatStatus::Completed;
            progress.formats[idx].domains_written = total_domains;
            progress.formats[idx].percent = 100.0;
            progress.formats[idx].gz_size = Some(output_file.size_bytes);
            output_files.push(output_file);
        }

        progress.current_format = None;
        progress_callback(&progress);

        Ok(output_files)
    }

    /// Generate a single category file (for parallel execution)
    fn generate_category_file(
        &self,
        category: Option<&str>,
        format: OutputFormat,
        domains: &[String],
    ) -> Result<OutputFile> {
        let total_domains = domains.len() as u64;

        // Filename: category_format.txt.gz or uncategorized_format.txt.gz
        let filename = match category {
            Some(cat) => format!("{}_{}.txt.gz", cat, format.as_str()),
            None => format!("uncategorized_{}.txt.gz", format.as_str()),
        };
        let output_path = self.output_dir.join(&filename);

        // Create gzip encoder with fast compression
        let file = File::create(&output_path)?;
        let buf_writer = BufWriter::with_capacity(4 * 1024 * 1024, file);
        let mut encoder = GzEncoder::new(buf_writer, Compression::fast());

        // Write header
        let header = self.generate_header(format, total_domains);
        encoder.write_all(header.as_bytes())?;

        // Write all domains
        for domain in domains {
            Self::write_domain(&mut encoder, format, domain)?;
        }

        // Finish compression
        let buf_writer = encoder.finish()?;
        buf_writer.into_inner()?.sync_all()?;
        let gz_size = fs::metadata(&output_path)?.len();

        info!(
            "Generated {} ({} domains, {} bytes compressed)",
            filename, total_domains, gz_size
        );

        Ok(OutputFile {
            name: filename,
            format: format.as_str().to_string(),
            size_bytes: gz_size,
            domain_count: total_domains,
        })
    }

    /// Generate output files for all categories in parallel
    pub fn generate_all_categories(
        &self,
        category_domains: &HashMap<Option<String>, Vec<String>>,
    ) -> Result<Vec<OutputFile>> {
        // Ensure output directory exists before parallel execution
        fs::create_dir_all(&self.output_dir)?;

        // Build task list: (category, format) pairs with domain reference
        let tasks: Vec<(Option<&str>, OutputFormat, &[String])> = category_domains
            .iter()
            .flat_map(|(cat, domains)| {
                OutputFormat::all().into_iter()
                    .map(move |fmt| (cat.as_deref(), fmt, domains.as_slice()))
            })
            .collect();

        info!(
            "Generating {} category files ({} categories Ã— 3 formats)",
            tasks.len(),
            category_domains.len()
        );

        // Generate all files in parallel using rayon
        let results: Vec<Result<OutputFile>> = tasks
            .par_iter()
            .map(|(category, format, domains)| {
                self.generate_category_file(*category, *format, domains)
            })
            .collect();

        // Collect results
        let output_files: Result<Vec<OutputFile>> = results.into_iter().collect();
        output_files
    }

    /// Clean up old output files
    pub fn cleanup_old_files(&self) -> Result<()> {
        if !self.output_dir.exists() {
            return Ok(());
        }

        // Remove any legacy uncompressed files
        for entry in fs::read_dir(&self.output_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.extension().map(|e| e == "txt").unwrap_or(false) {
                // Check if it's not a .gz file (legacy uncompressed)
                let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
                if !filename.ends_with(".gz") {
                    info!("Removing legacy uncompressed file: {:?}", path);
                    fs::remove_file(path)?;
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_write_domain() {
        let mut buf = Vec::new();

        OutputGenerator::write_domain(&mut buf, OutputFormat::Hosts, "example.com").unwrap();
        assert_eq!(String::from_utf8(buf.clone()).unwrap(), "0.0.0.0 example.com\n");

        buf.clear();
        OutputGenerator::write_domain(&mut buf, OutputFormat::Plain, "example.com").unwrap();
        assert_eq!(String::from_utf8(buf.clone()).unwrap(), "example.com\n");

        buf.clear();
        OutputGenerator::write_domain(&mut buf, OutputFormat::Adblock, "example.com").unwrap();
        assert_eq!(String::from_utf8(buf).unwrap(), "||example.com^\n");
    }

    #[test]
    fn test_generate_file() {
        let temp_dir = TempDir::new().unwrap();
        let generator = OutputGenerator::new(temp_dir.path());

        let domains = vec!["ads.example.com".to_string(), "tracker.example.com".to_string()];

        let output = generator
            .generate_file(OutputFormat::Hosts, &domains, |_, _| {})
            .unwrap();

        assert_eq!(output.format, "hosts");
        assert_eq!(output.domain_count, 2);
        assert!(output.size_bytes > 0);
        assert!(temp_dir.path().join(&output.name).exists());
    }
}
